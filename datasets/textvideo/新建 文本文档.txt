[GitHub项目地址](https://github.com/HarrykingZLH/No_more_bets)

[bilibili视频链接](https://www.bilibili.com/video/BV1Xm4y1g7n6/?buvid=Y54164584F04BBE4412DB80A431B04C9BB08&is_story_h5=false&mid=P10D3XOP4LLRbL3lY1oOLA%3D%3D&p=1&plat_id=116&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=39A36369-E53A-4F60-A201-7D4468489DD0&share_source=QQ&share_tag=s_i&timestamp=1697125366&unique_k=GodjksL&up_id=527027219&vd_source=884af3d08eeae21ab00e4b40b06e8ca8)

# 一、结对探索

## **1.1 队伍基本信息**

- 结对编号：__30__；队伍名称：__坤坤爆__；

|   学号    |  姓名  | 作业博客链接 | 具体分工 |
| :----: | :----: | :-------: | :------: |
| 102101535 | 郭子浩 |  https://bbs.csdn.net/topics/617402370          |     算法书写    |
| 102101527 | 郑龙辉 |    https://bbs.csdn.net/topics/617402472         |      样式设计    |

## 1.2 描述结对的过程 

- 由于平常就经常一起学习讨论一些问题，所以在知道是两个人完成项目之后，就达成了一拍即合的结对

## **1.3 非摆拍的两人在讨论设计或结对编程过程的照片**

![img](https://img-community.csdnimg.cn/images/09887774dc54480ba2a7ccd7b6ecb357.png "#left")

# 二、原型设计

## 2.1 **原型工具的选择**

- 此次作业中，我们根据需求，综合了**协同创作**、**素材库**、**兼容性**、**上手难度**、**功能**等因素考量，选择了墨刀原型
( [墨刀在线平台链接](https://modao.cc/usergrowth/prototype/design-b.html?jsid=SEM-BAIDU-modao2-PP-0038&bd_vid=9168481702278692386 "墨刀链接") )
- 选择原因：
  - **简单易用**：墨刀提供了直观友好的用户界面，非常**易于上手和使用**，对于我们之前从未接触过原型设计的小白而言，可以让我们在原型设计这一块节约时间，把时间尽可能多的放在小程序样式设计以及算法实现上。
  - **功能丰富**：墨刀在简单易用的同时，在功能方面也有不俗的表现，有多种的**交互方式**(如点击、滑动和悬停等)、**动画滚动**(如滑动、旋转等等)、**自制组件**(墨刀自制组件的功能，为我们小程序这种有许多重复页面的需求提供了极大的便捷)等等，可以让我们在原型中就模拟出真实的用户体验。
  - **高效协作**：墨刀作为一个原型设计协作工具，支持多人实时协作，可以和我的队友共同编辑原型，提高了我们的协作效率。

##  **2.2 遇到的困难与解决办法**

- 学了好多视频里教的的墨刀使用方法，在水平滑动图上卡了很久，最后通过查阅资料的方式解决了。
- 在设计交互性方面推翻了好几个版本，一直在思考使得用户简单易上手的交互提醒，通过激烈的讨论之后，得到的一个最终版本
- 收获：锻炼了我们的UI设计能力和墨刀这种原型设计工具的使用能力，第一次进行UI设计，学到了非常多的自制组件的技巧。

##  **2.3 原型作品链接**
  [原型作品](https://modao.cc/proto/hvigZleKs2f0tbx4dyLSPj/sharing?view_mode=read_only)
## **2.4 原型界面图片展示**

**首页**
- 这里就是我们作品的创新，融入了班级特色创意元素
- 首页部分我们共三个模块，点击规则按钮可以查看当前游戏的规则，点击排行榜可以看到和人机对战之后的得分情况，这里的分数是净胜
分数噢，即游戏结束时的筹码 - 游戏开始时的筹码。(和越困难的人机对战得分会越多哦)
- 创新点在于：开始、规则和排行榜按钮都和语义很贴近。并且融入班级特色创意，kx老师的缩写，同样是开心的缩写，寓意着开心，希望玩这款小程序的人都会收获快乐

![img](https://img-community.csdnimg.cn/images/b4bfc3f346cb474aadf0317cebb94cce.png "#left")



**规则**
- 规则部分我们采用可以向下滑动的页面，并配上轮播图帮助玩家理解游戏规则，图文并茂且通俗易懂的解释了游戏规则
- 创新点在于：骰子的精美和轮播图，图文并茂的展示了游戏规则


![img](https://img-community.csdnimg.cn/images/6502026eaa474e04b7fbf833eb7776dd.png "#left")


**模式选择**
- 模式选择部分我们可以选择三个模式，分别是本地对战，人机对战和联机对战，分别配上三个精美图标
- 创新点在于：本地对战，人机对战和联机对战的图标都很贴近语义，并且简约的样式可以使得用户更加清楚应该如何选择，不会误触


![img](https://img-community.csdnimg.cn/images/f40ad17b6ce14e328ffd4fbac8893b35.png "#left")


**排行榜**
-  排行榜部分我们列举了和人机对战之后的得分情况，和不同等级的人机对战，所获得的分数不同。与越困难的人机对战，所记录的分数
就是越多的，即为(游戏结束时的筹码 - 游戏开始时的筹码) * 难度奖励
- 创新点在于排行榜部分规则的设定，在记录的同时不乏合理性

![img](https://img-community.csdnimg.cn/images/924b271feee3498ab8fae9aa4a0845be.png "#left")


**两人对战游戏设置**
-  两人对战游戏设置部分我们可以设置游戏的总局数，玩家1的筹码和玩家2的筹码，使本地对战增加更多可玩性。用户可以将局数和筹码数增大，以长期博弈。亦或者将局数和筹码数减小，追求少量局数而带来的刺激感。
- 创新点在于可以设置的总局数和玩家筹码，丰富了游戏的可玩性

![img](https://img-community.csdnimg.cn/images/030238ee92c54f3c80dc795620e14ed9.png "#left")


**联机对战选择**
- 联机对战选择部分我们可以选择三个模式，分别是创建对战房间，加入对战房间和在线匹配对战，在此处我们选择设计简约的风格以保证用户的清晰易懂。
- 创新点在于简约的样式可以使得用户更加清楚应该如何选择，不会误触

![img](https://img-community.csdnimg.cn/images/c093cb76ee8444b79b3672263313c8e9.png "#left")


**人机对战游戏设置**
- 人机对战游戏设置部分我们设置了许多输入框，首先可以选择游戏难度，困难的人机采取的策略很优秀，而普通人机采取的策略较为一般，简单人机基本上是为了给用户带来胜利的喜悦。其中输入昵称框，意为若游戏中表现右移，冲进得分前十，会被记录在排行榜中而玩家筹码、人机筹码、总局数则是给人机对战带来更多可玩性
- 创新点在于人机难度的选择，需要想出三种策略，并且这三种策略在表现上能够有显著性差异，以及输入用户昵称框，帮助表现右移的用户将自己的名字记录在排行榜中

![img](https://img-community.csdnimg.cn/images/0ce33fbd2fe34fb9b7889b08d8375ff0.png "#left")

**创建房间**
- 在创建房间的界面上，我们采用了简约的分格布局，以提供用户友好的界面体验。用户可以在此界面上输入房间号和密码，从而创建一个房间，并等待对手的加入，以进行一场双人对战。
- 创新点在于提供了一种简单而有序的方式，让用户能够创建游戏房间，并等待对手的加入，同时强调了多终端游戏体验以及用户等待过程中的反馈。这将有助于提高游戏的吸引力和互动性。
![img](https://img-community.csdnimg.cn/images/18c19bde947643a78cc17e6cae067158.png "#left")


**联机对战加入房间**
- 在联机对战加入房间的界面上，我们采用了简约的分格布局，以提供用户友好的界面体验。用户可以在此界面上输入房间号和密码，从而进入指定房间，以进行一场双人对战。
- 创新点在于提供了一种简单而有序的方式，允许用户加入指定房间，同时加强了用户对搜索进程的感知，提高了整体的用户体验。

![img](https://img-community.csdnimg.cn/images/31e47893238940568f4d5dda5a154602.png "#left")

**对战界面**
- 首先，在页面的顶部，我们有大标题显示局数和回合数，小标题则反映当前的总倍率。这个设计的创新点在于提供了一目了然的游戏进展信息，使玩家在比赛中始终保持清晰的头脑。
- 接下来，对战界面呈现在玩家面前，左右分别代表双方玩家，这也可以包括人机对战选项。在这个界面中，有一个投掷区和一个锁定区。一个独特的创新点是，在投掷瞬间，骰子会从原有状态变成盲盒，然后随机点数被揭示。这种设计增加了悬念和紧张感，使游戏更具刺激性。
- 在锁定期间，自由的骰子可以在两个区域自由移动，但已经锁定的骰子无法再次移动。这带来了策略性的考量，使玩家需要谨慎选择哪些骰子锁定，以及如何在锁定后最有效地利用它们。警告机制的引入增加了游戏的深度和挑战性。
- 最引人注目的创新点是这个界面的强交互性。每个瞬间只能执行一项操作，只有一个按钮供玩家选择，以最大程度地防止误触。这种设计增加了游戏的策略性和战术性，同时提供了更丰富的游戏体验。此外，每个动作都有弹窗提醒以及相应，提供了反馈和可视化效果，增强了玩家的互动感。
- 最后，游戏提供了结算界面，供选手分析比赛的结果。这个创新点允许玩家回顾他们的策略，了解游戏进展，以便更好地规划下一轮的比赛。这种反馈和分析工具使游戏更具学习性和竞技性。

![img](https://img-community.csdnimg.cn/images/18f350cb41bc4aa5b19c3d538ae10bcb.png "#left")


# 三、编程实现

## 3.1 **网络接口的使用**

- 在网络接口上，我们利用微信中获取用户信息的接口wx.getUserProfile()，询问用户是否将用户信息授权给小程序后，获取用户信息，在此基础上进行联机对战。

- 用户授权登录接口

```
get_user(){
const app = getApp();
      if(app.globalData.userInfo == null){
        this.get_user_data();
      }
      else{
        wx.showToast({
          title: '已授权用户信息',
        })
      }
    },
    get_user_data(){
      wx:wx.getUserProfile({
        desc: '用于进入联机对战',
        lang: 'zh_CN',
        success: (result) => {
          console.log('用户授权成功');
          wx.navigateTo({
            url: '/pages/wifi_pk/wifi_pk'
          })
        },
        fail: (res) => {
          console.log('用户取消授权');
        },
        complete: (res) => {
          console.log('选择完毕');
        },
      })
    }
```


- 同时用上了许多UDP连接的接口

```
  wx.createUDPSocket()
  {
      //创建UDP套接字实例
  }
  UDPSocket.bind(number port)
  {
      //套接字绑定端口号
  }
  UDPSocket.onListening(function callback)
  {
      //开始监听数据包信息的事件
  }
  UDPSocket.onMessage(function callback)
  {
      //监听收到消息的事件
  }
  UDPSocket.send(Object object)
  {
      //向指定的IP和port发送消息
  }
  UDPSocket.close()
  {
      //关闭套接字连接
  }
```

## 3.2 代码组织与内部实现设计（类图）**

- 代码组织：

  
  ![img](https://img-community.csdnimg.cn/images/54dcf8eb8ce44ea38d5426b8d232842f.png "#left")


- 内部实现设计(类图)：

  - 首先先定义一个玩家类，用来存玩家的随机骰子区和锁定骰子区，并且记录玩家筹码等信息
  - 由于人机是自动投掷的，所以如果用玩家类来控制有许多冗余变量，这里特别定义一个人机类，用来人机对战
  - 由于要实现一个排行榜功能，所以定义了一个具有用户名和用户最终筹码的类，用于排名


  ![img](https://img-community.csdnimg.cn/images/b5a59a10f2e64da995d1b4da9e4f096e.png "#left")


  ​

## **3.3 说明算法的关键与关键实现部分流程图**

- **两人对战：**两人对战中没有什么特别的算法，就只是流水账式的实现所需要的功能，值得一提的是计算奖励分方面，我们用的是差分算法，使整体代码更加美观，在减少了代码的繁琐度，具体将在"3.4贴出重要的/有价值的代码片段并解释"详细介绍。

- **人机对战：**人机对战中，除了用了上述的计算奖励分所用的差分算法，还用到了六叉树的数据结构，并利用记忆化搜索的方式遍历了整棵树，降低时间复杂度为O(N)，N为树上结点数，具体将在"3.4贴出重要的/有价值的代码片段并解释"详细介绍。

- **联机对战：**同样的，除了利用差分算法计算奖励分，还有利用UDP实现网络通信，实现局域网内的联机功能。

- **实现部分流程图：**


![img](https://img-community.csdnimg.cn/images/80705d2bdc114ef5a3f22dee73810b37.png "#left")


## 3.4  **贴出重要的/有价值的代码片段并解释**

- 最重要的就是奖励分的计算和人机选择骰子时的策略方面的代码了，其他就是简单的流水账式的代码编写，以下介绍这两个部分。

- **六叉树的建立和遍历：**首先根据可能存在的骰子状态算出一共有9331种状态，这里利用数组存储节点值，实现六叉树的数据结构。由二叉树(根节点为0)左儿子索引为(2 \* x+1)，右儿子为(2 \* x + 2)可以推知，六叉树的儿子节点分别为(6 \* x + i),其中i为骰子点数。因此先通过填充叶子结点的值，在通过记忆化搜索的方式，用flag数组记录当前节点是否被访问过，如果访问过则跳过，这样处理可以保证每个节点只会被遍历一次，将时间复杂度显著降低的同时，填充完整棵树节点的值。

  ```
  def Cal_E(depth,index):
      if(flag[index]): //如果访问过，则跳过
          return flag[index]
      if depth >= 5:	//根节点算深度为0，深度大于等于5则跳过
          return
      for i in range(1, 7):
          hexary_tree[index] += Cal_E(depth + 1, index * 6 + i)	//递归求解
      hexary_tree[index] /= 6.0
      return flag[index] == hexary_tree[index]	//记录flag数组

  def push_Hexary_Tree(index,score):
      hexary_tree[index] = score

  def leaves():	//叶子结点的计算
      alist = [0,0,0,0,0]
      for i in range(1,7):
          for j in range(1, 7):
              for k in range(1, 7):
                  for m in range(1, 7):
                      for n in range(1, 7):
                          total_score = get_total_score([i, j, k, m, n])	//调用分数计算函数
                          push_Hexary_Tree(((((0 * 6 + i) * 6 +j) * 6 + k) * 6 + m) * 6 + n, total_score)
  ```

- **奖励分的差分方法计算：**由于常规的枚举算分代码实在是繁琐，写的很累。这里想到了用差分数组的方式实现分数的计算。差分即为将已排过序的数组(长度为n)进行相邻之间的作差，得到长度为n-1的差分数组。这里讲解几个例子：如果是五连，差分数组一定是四个0；如果是大顺子，差分数组一定是四个1；如果是四连，差分数组一定是在三个0的同时，原数组第二个数一定和第四个数相等。

  ```
  def get_total_score(alist):	//分数计算函数
      alist.sort()
      total_score = sum(alist)
      total_score += extra_bonus(alist)
      return total_score
  def extra_bonus(arr):	//奖励分计算函数
      num = [0] * 7
      for i in range(5):
          num[arr[i]] += 1
      arr_dist = []
      for i in range(len(arr) - 1):	//得到差分数组
          arr_dist.append(arr[i + 1] - arr[i])
      if arr_dist.count(0) == 4:	//五连
          return 100
      elif arr_dist.count(1) == 4:	//大顺子
          return 60
      elif arr_dist.count(0) == 3 and (arr[1] == arr[3]):	//四连
          return 40
      elif all(num[i] >= 1 for i in range(1, 5)):	//小顺子
          return 30
      elif all(num[i] >= 1 for i in range(2, 6)):	//小顺子
          return 30
      elif all(num[i] >= 1 for i in range(3, 7)):	//小顺子
          return 30
      elif arr_dist.count(0) == 3 and (arr[1] != arr[3]):	//葫芦
          return 20
      elif arr_dist.count(0) == 2:	//三条和两对
          return 10
      else:
  ```

##  **3.5 性能分析与改进**

- 这里利用微信开发者工具自带的性能测试跑了一下，发现占用的内存还是比较大的，所以将图片进行了压缩处理，降低清晰度的同时减少了给用户手机带来的负担


![img](https://img-community.csdnimg.cn/images/5879dde348184ccbb5973ce680b5673e.jpg "#left")


- 利用pycharm专业版自带的工具，同时测了一下所需的时间

- 性能分析图：


![img](https://img-community.csdnimg.cn/images/64a872c11c8f43b09b84c20013ede913.jpg "#left")


- 开销最大的函数：Cal_E()函数，即为计算整棵树节点值(当前状态的期望)的函数

- 改进思路：因为无法用线程或者进程进行改进，这里利用记忆化搜索改进算法，利用记忆数组的条件判断，使得每个节点只会被遍历一次，时间被大幅度减少，从原来的指数级别降低为线性级别的复杂度。

```
    def Cal_E(depth,index):
        if(flag[index]): //如果访问过，则跳过
            return flag[index]
        if depth >= 5:	//根节点算深度为0，深度大于等于5则跳过
            return
        for i in range(1, 7):
            hexary_tree[index] += Cal_E(depth + 1, index * 6 + i)	//递归求解
        hexary_tree[index] /= 6.0
        return flag[index] == hexary_tree[index]	//记录flag数组

    def push_Hexary_Tree(index,score):
        hexary_tree[index] = score

    def leaves():	//叶子结点的计算
        alist = [0,0,0,0,0]
        for i in range(1,7):
            for j in range(1, 7):
                for k in range(1, 7):
                    for m in range(1, 7):
                        for n in range(1, 7):
                            total_score = get_total_score([i, j, k, m, n])	//调用分数计算函数
                            push_Hexary_Tree(((((0 * 6 + i) * 6 +j) * 6 + k) * 6 + m) * 6 + n, total_score)
```

## **3.6 单元测试**

- 这里利用python自带的unittest库进行单元测试，检测AI做出的选择是否正确

```python
import unittest
import 期望计算 as Cal_e
import 初始算法_人机对战 as play_vs_AI

dice_lists = [[2, 2, 5, 5, 1], [1, 1, 1, 5, 6], [5, 5, 5, 6, 6], [2, 2, 2, 2, 3], [6, 6, 6, 6, 6], [1, 2, 3, 4, 6],
            [1, 2, 3, 4, 5]]
score_lists = [25, 24, 47, 51, 130, 46, 75]

AI_score = [24, 23, 28, 34, 45, 12]
play_socre = [25, 21, 24, 35, 21, 34]

mul_res = [0, 3, 3, 0, 3, 0]


class Mytest(unittest.TestCase):

def test_cal_e(self):
    list_len = len(dice_lists)
    for i in range(list_len):
        cal_score = Cal_e.get_total_score(dice_lists[i])
        self.assertEqual(cal_score, score_lists[i])

def test_cal_multiply(self):
    list_len = len(AI_score)
    for i in range(list_len):
        res = play_vs_AI.AI_multiply(AI_score[i], play_socre[i])
        self.assertEqual(res, mul_res[i])


if __name__ == '__main__':
unittest.main()


```
 

- 测试结果：

 
![img](https://img-community.csdnimg.cn/images/16672827db9f4f84bf8288036f7ed435.jpg "#left")


## 3.7 **贴出GitHub的代码签入记录，合理记录commit信息** 

- 将初始版本和最终版本记录在GitHub仓库中，如下图所示：


![img](https://img-community.csdnimg.cn/images/399a6475bdf2497ba5ad36337399ea44.png "#left")




![img](https://img-community.csdnimg.cn/images/8e0a8f0bf76d47b69b358c6b0efb09de.png "#left")




# 四、总结反思

##  **4.1 本次任务的PSP表格**
| PSP   | Personal Software Process Stages | 预估耗时（分钟） | 实际耗时（分钟） |
| ------ | ------ | ------ | ------ |
| Planning | 计划 | 10 | 5 |
| Estimate | 估计这个任务需要多少时间 | 30 | 60 |
| Development | 开发 | 7610 | 7940 |
| Analysis | 需求分析 (包括学习新技术) | 7580 | 7780 |
| Design Spec | 生成设计文档 | 680 | 770 |
| Design Review | 设计复审 | 500 | 250 |
| Coding Standard | 代码规范 (为目前的开发制定合适的规范) | 300 | 340 |
| Design | 具体设计 | 1000 | 1200 |
| Coding | 具体编码 | 4200 | 4430 |
| Code Review | 代码复审 | 120 | 80 |
| Test | 测试（自我测试，修改代码，提交修改） | 300 | 350 |
| Reporting | 报告 | 240 | 300 |
| Test Repor | 测试报告 | 60 | 50 |
| Size Measurement | 计算工作量 | 60 | 50 |
| Postmortem & Process Improvement Plan | 事后总结, 并提出过程改进计划 | 120 | 60 |
|  | 合计 | 7610 | 7940 |


##  **4.2 学习进度条（每周追加）**

- 102101535郭子浩


|     第N周     |        新增代码(行)         | 累积代码(行) | 本周学习耗时(小时) | 累计学习耗时（小时） | 重要成长 |
| :-----------: | :-------------------------: | :----------: | :----------: | :------------------: | :------: |
|       1       |           0            |      0      |      8      | 8 | 学会了原型设计工具墨刀，下载微信开发者工具，并了解了wxml和js语言 |
|       2       | 328 |     328      |     12     | 20 | 用python将两人对战在控制台实现，熟悉两人对战游戏流程和实现过程，能够熟练编写wxml语言 |
| 3 |           257         |     585      |     13     | 33 | 用python将人机对战在控制台实现，熟悉人机对战游戏流程和实现过程，能够熟练编写JavaScript语言 |
|  4   | 5374 |     5959    |     42      | 75 | 将python代码用JavaScript实现，实现了人机对战，并和队友一起增添了联机对战、排行榜等功能，锻炼了代码的书写能力，学习了UDP连接相关知识 |


- 102101527郑龙辉

|     第N周     |        新增代码(行)         | 累积代码(行) | 本周学习耗时(小时) | 累计学习耗时（小时） | 重要成长 |
| :-----------: | :-------------------------: | :----------: | :----------: | :------------------: | :------: |
|       1       |           0            |      8      |      9      | 9 | 学习了原型设计工具墨刀，下载微信开发者工具，并了解了wxml、js和wss语言 |
|       2       | 328 |     328    |     11    | 20 | 熟练编写wxml和js语言，设计原型，并实现交互性很强的原型作品 |
| 3 |           257         |     585      |     13    | 33 | 熟练编写wxml、js和wss语言，得到初步全局样式 |
|  4   | 5374 |     5959  |   45    | 77 | 将python代码用JavaScript实现，实现了本地对战，全局的调整了样式，和队友一起增添了联机对战、排行榜等功能，锻炼了代码能力，学习了UDP连接相关知识 |

## 4.3 最初想象中的产品形态、原型设计作品、软件开发成果三者的差距如何？（也就是谈一谈本次任务中**“理想与现实的差距”**，是哪些因素造成了这些差距？）

- 最开始想象的产品形态会是类似于已有的斗地主、德州扑克等微信小程序那种样式，但出于想把小程序做的特别一些，而不是像当今大多纸牌类小程序所设计的那样，整体风格在花哨的同时带点土味。所以在原型设计时，我们决定把整个小程序的风格设计的简约一些，更加符合现在年轻人的审美。在功能方面，最初想象，还没有入手实践时觉得很多功能都是非常难实现的，最初的原型设计中也没有设计对应功能，但在持续努力之下，还是实现了一些之前认为很困难的功能。所以最初想象中的产品形态和原型设计作品与软件开发成果之间还是存在着很大的差距。
- 导致差距的因素：应该是因为我们两个都是第一次开发小程序，缺乏在软件或小程序开发方面的学习，所以还没入手学习的时候十分的悲观。还有就是后期的不断努力吧，在努力中不断拆解所需要的实现的功能，一步步实现了之前认为不可能实现的功能。

## 4.4 评价你的队友（分别评价队友**值得学习的地方**和**需要改进的地方**）

**102101535郭子浩：**

- **值得学习的地方**：我认为我的队友郑龙辉代码能力很强，审美也始终在线，ui设计的非常特别且好看，沟通能力很强，并且学习能力很强，效率很高，能够很快的适应新的开发模式和工具，遇到的问题基本都可以自己独立解决，并且在项目开发中也十分的认真负责，一起连续三天熬到了凌晨四五点，具有坚持不懈的精神，做事情十分严谨，代码规范性和可读性也非常好。
- **需要改进的地方**：龙辉太完美了，唯一需要改进的地方可能是和我一样有点拖延症哈哈哈哈哈，前期事情一多就想着等到后面在做小程序，导致后面有点赶。

**102101527郑龙辉：**

- **值得学习的地方**：首先是协作能力，郭子浩在团队中展现出卓越的协作能力，他善于与他人合作，积极倾听他人的意见，并能够有效地与他人一起完成任务；再有就是沟通技巧，他擅长沟通，能够清晰表达自己的想法和观点，同时也懂得倾听他人的反馈。他善于用文字、口头和非语言方式与团队成员有效地交流；最后便是可靠性，他非常可靠。按时履行承诺，始终如一地完成任务，让团队成员能够依赖他。
- **需要改进的地方**：首先是时间管理，郭子浩可能需要改进时间管理技能，以确保按时完成任务和项目。他可以学习如何制定优先级，设定工作时间表，以提高效率；再来便是决策能力，他有时可能需要可能需要提升自己的决策能力，尤其是在面对复杂的问题和压力情况下。他可以学习如何做出明智的决策，并在必要时请教他人的意见。

## **4.5 结对编程作业心得体会**

**102101535郭子浩：**

- **评价作业难度：**作业在实现联机功能方面难度好大，涉及到很多UDP通信的相关知识，之前只有了解了一点理论知识，而没有真正的动手实践过。并且对我而言，在wxml，wxss，JavaScript方面也是需要一些时间进行学习，并且人机选择策略方面，也是经过了许多考虑，最后敲定了策略，作业难度还是很大的。
- **完成后的感受：**尽管在开发的过程中时常经历痛苦和挑战，但一旦完成整个小程序，那种成就感真是难以言喻。此外，回顾之前的代码编写过程时，我也发现了许多不足之处，这为我提供了宝贵的学习机会。完成项目后，总结整个过程是非常有益的，因为这个过程中我能够汲取宝贵的经验教训。这样的反思和总结使我在不断成长和提高的道路上更进一步。尽管开发过程充满挑战，但最终的成就感和学到的经验是宝贵的奖赏，让我更加坚定了在软件开发领域不断前行的信心。
- **遇到的困难：**最大的困难可能就在联机对战方面了，一个报错调了很久非常非常久。对于这块，网络上可查阅的资源也非常少，最后通过和队友的讨论和对AI的提问解决了这个困难。其他困难的话，就在于微信开发者工具里js的编写了，由于是速成的js，在js的基础十分薄弱，很多函数都只知道运用，并不了解底层深层次的实现，比如wx.navigateTo({})和wx.redirectTo({})在页面跳转中页面是否入栈的问题，由于页面出栈速度十分缓慢，而若点击过快就会导致小程序崩溃的问题。
- **对之后学习或软件开发的启发：**实际开发完一个软件或小程序后，我深刻领悟到问题拆分的至关重要性。将问题分解成小块，逐一解决，有助于将复杂任务变得更加可管理。这样的拆分策略不仅使问题碎片化，也让我们能够逐步解决，从容面对，先从相对容易的部分着手，然后逐渐挑战难点。
在整个开发过程中，在正式开始之前，规划好每个时间点应该完成的任务和进度，持续更新进度，是确保项目成功的关键步骤。这种细致的规划和及时的进度追踪不仅有助于确保整体开发顺利进行，还能够在遇到问题时更快地做出调整，确保项目按计划完成。这次经验教会了我，在软件开发中，合理的问题拆分和周密的计划管理是取得成功的关键。
- **统筹规划：**在这次开发过程中，前期事务繁琐，不可避免地导致了开发进展相对较为缓慢。然而，在截止日期临近的紧要关头，我以极其认真的态度，全身心地投入到功能的完善工作中，坚定地没有因时间紧迫而轻易妥协。这一经历深刻锻炼了我的坚韧与毅力，使我更坚信，无论遇到怎样的压力和挑战，都能保持坚定前行的决心。

**102101527郑龙辉：**

- **评价作业难度：**这充满了充分挑战性的环境激发了我们积极主动地应用所学知识来克服各种难题，每一个挑战都如同一次精彩的谜题等待着我们的解锁。在这个过程中，我们不仅没有丧失信心，反而更坚定了自己的信念，坚信无论面临何种复杂情境，我们都有能力克服一切。
- **完成后的感受：**完成任务之后，我们沐浴在巨大的成就感和深切的满足感之中，这种喜悦超越了一般的胜利感。它仿佛是一场精神的盛宴，我们的自尊心和动力都得到了极大的滋养，让我们更加坚信自己的潜力和能力。这个过程让我们深刻体会到，无论遇到何种挑战，只要充分发挥已学知识和坚韧的毅力，最终的胜利将带来前所未有的喜悦。
- **遇到的困难：**在 JavaScript 中，对于页面跳转，wx.navigateTo({}) 和 wx.redirectTo({}) 方法都涉及页面是否入栈的问题。这一细节在实际应用中变得尤为关键，因为在小程序中，页面的出栈速度相对缓慢，这会引发一系列问题。尤其当用户点击操作过于频繁时，可能导致小程序系统性能崩溃的风险不容忽视。wx.navigateTo({}) 会将新页面压入栈中，允许用户后退到之前的页面，这在某些场景下非常有用，但过多的页面入栈可能导致内存占用增加，性能下降，以及页面切换的混乱。相对地，wx.redirectTo({}) 会关闭当前页面并直接打开新页面，不会形成页面栈的层级，这节省了一部分内存和性能，但也意味着用户无法回退到之前的页面。因此，在小程序开发中，需要仔细权衡何时使用哪种跳转方式，以最大程度地优化用户体验和小程序性能。特别要留心处理用户可能的连续点击行为，采用适当的节流和防抖策略，以减少潜在的小程序崩溃风险，确保流畅的用户操作体验。
- **对之后学习或软件开发的启发：**我深刻理解的是，要在软件开发领域取得成功，维持积极的态度和充沛的耐心至关重要。软件开发是一门高度复杂的任务，它的不断演化和变化要求我们始终保持学习和实践的动力。不仅如此，软件开发也融合了创造性和解决问题的要素，需要我们在抽象思维和具体实施之间找到平衡。在这个旅程中，积极的态度能够充实我们的内心，鼓舞我们去克服各种障碍和挑战。耐心则是我们前进的动力，因为它使我们有能力追求完美、解决困难，同时也是继续学习的动力源。要成为一名出色的软件开发者，我们需要坚守这一信念，不断磨砺自己的技能，推陈出新，保持谦逊，并在不断学习的过程中积累经验，以应对不断变化的行业需求。在软件开发的旅程中，积极的态度和坚韧的耐心将成为我们不可或缺的伴侣，引领我们前进，实现我们的目标。
- **统筹规划：**在未来，我坚决决定要更加精心地规划我的时间，确保给自己足够的时间来应对各种挑战和任务。时间管理对于取得成功至关重要，因为它能够提高效率、减少压力，让我能够更好地平衡工作、学习和休闲生活。我计划采用更智慧的方式来安排任务，包括设置合理的工作时间、设定明确的目标，以及学会拒绝一些不必要的事情，以确保我有更多的时间和精力投入到最重要的事情上。此外，我也将学习更好地利用工具和技巧，如时间管理应用程序、待办清单和提醒功能，以帮助我更好地组织和管理我的日常工作。保持充裕的时间是一种珍贵的资源，它能够让我更好地追求自己的目标、提高效率、减轻压力，以及创造更多的机会来享受生活。我深信，通过更好的时间管理和规划，我将能够更好地实现我的愿望和抱负。























